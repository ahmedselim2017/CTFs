//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t is_invalid(int64_t a1);
int64_t print_flag(void);
int64_t string_to_int(int64_t str, int64_t * a2);

// --------------------- Global Variables ---------------------

struct _IO_FILE * g1 = NULL; // 0x6020b0
int32_t g2;

// ------------------------ Functions -------------------------

// Address range: 0x400877 - 0x40093e
int64_t print_flag(void) {
    int64_t v1 = __readfsqword(40); // 0x400882
    int32_t v2 = getegid(); // 0x400891
    setresgid(v2, v2, v2);
    struct _IO_FILE * file = fopen("flag.txt", "r"); // 0x4008c5
    if (file == NULL) {
        // 0x4008db
        puts("Cannot read flag file.");
        exit(1);
        // UNREACHABLE
    }
    // 0x4008f1
    int64_t str; // bp-152, 0x400877
    fgets((char *)&str, 128, file);
    printf("%s", &str);
    int64_t result = 0; // 0x400935
    if (v1 != __readfsqword(40)) {
        // 0x400937
        __stack_chk_fail();
        result = &g2;
    }
    // 0x40093c
    return result;
}

// Address range: 0x40093e - 0x40096d
int64_t string_to_int(int64_t str, int64_t * a2) {
    // 0x40093e
    return sscanf((char *)str, "%d", a2);
}

// Address range: 0x40096d - 0x40098e
int64_t is_invalid(int64_t a1) {
    int32_t v1 = a1; // 0x400971
    if (v1 < 0) {
        // 0x40098c
        return 1;
    }
    // 0x40097a
    return v1 > 9;
}

// Address range: 0x40098e - 0x400bdd
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x4009a6
    puts("So you figured out how to provide input and command line arguments.");
    puts("But can you figure out what input to provide?");
    int64_t v2; // 0x40098e
    if ((int32_t)argc == 5) {
        int64_t v3 = (int64_t)argv; // 0x4009ec
        int32_t v4; // bp-180, 0x40098e
        string_to_int(*(int64_t *)(v3 + 8), (int64_t *)&v4);
        int32_t v5; // bp-176, 0x40098e
        string_to_int(*(int64_t *)(v3 + 16), (int64_t *)&v5);
        int32_t v6; // bp-172, 0x40098e
        string_to_int(*(int64_t *)(v3 + 24), (int64_t *)&v6);
        if ((int32_t)is_invalid((int64_t)v4) != 0) {
            // 0x400aca
            puts("Don't try to guess the arguments, it won't work.");
            v2 = 1;
            goto lab_0x400bc7;
        } else {
            // 0x400a5d
            if ((int32_t)is_invalid((int64_t)v5) != 0) {
                // 0x400aca
                puts("Don't try to guess the arguments, it won't work.");
                v2 = 1;
                goto lab_0x400bc7;
            } else {
                // 0x400a6e
                if ((int32_t)is_invalid((int64_t)v6) != 0) {
                    // 0x400aca
                    puts("Don't try to guess the arguments, it won't work.");
                    v2 = 1;
                    goto lab_0x400bc7;
                } else {
                    // 0x400a7f
                    if (10 * v4 + 100 * v5 + v6 != 932) {
                        // 0x400aca
                        puts("Don't try to guess the arguments, it won't work.");
                        v2 = 1;
                        goto lab_0x400bc7;
                    } else {
                        // 0x400aa9
                        if (strcmp((char *)*(int64_t *)(v3 + 32), "chicken") == 0) {
                            // 0x400ae0
                            puts("Well, you found the arguments, but what's the password?");
                            int64_t str; // bp-152, 0x40098e
                            fgets((char *)&str, 128, g1);
                            char * found_char_pos = strchr((char *)&str, 10); // 0x400b16
                            if (found_char_pos != NULL) {
                                // 0x400b2c
                                *found_char_pos = 0;
                            }
                            int32_t len = strlen((char *)&str); // 0x400b40
                            if (len < 0) {
                              lab_0x400bac:
                                // 0x400bac
                                puts("Good job! You're ready to move on to bigger and badder rev!");
                                print_flag();
                                v2 = 0;
                            } else {
                                int32_t v7 = 0; // 0x400b97
                                int64_t v8 = v7; // 0x400b5d
                                int64_t v9; // bp-8, 0x40098e
                                char v10 = *(char *)((int64_t)&v9 - 144 + v8); // 0x400b5f
                                while ((v10 ^ 42) == *(char *)(v8 + (int64_t)"ZFOKYO\nMC\\O\nLFKM*")) {
                                    // 0x400b9e
                                    v7++;
                                    if (v7 > len) {
                                        goto lab_0x400bac;
                                    }
                                    v8 = v7;
                                    v10 = *(char *)((int64_t)&v9 - 144 + v8);
                                }
                                // 0x400b84
                                puts("I'm sure it's just a typo. Try again.");
                                v2 = 1;
                            }
                            goto lab_0x400bc7;
                        } else {
                            // 0x400aca
                            puts("Don't try to guess the arguments, it won't work.");
                            v2 = 1;
                            goto lab_0x400bc7;
                        }
                    }
                }
            }
        }
    } else {
        // 0x4009d6
        puts("Make sure you have the correct amount of command line arguments!");
        v2 = 1;
        goto lab_0x400bc7;
    }
  lab_0x400bc7:;
    int64_t result = v2; // 0x400bd4
    if (v1 != __readfsqword(40)) {
        // 0x400bd6
        __stack_chk_fail();
        result = &g2;
    }
    // 0x400bdb
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// void __stack_chk_fail(void);
// void exit(int status);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// __gid_t getegid(void);
// int printf(const char * restrict format, ...);
// int puts(const char * s);
// int setresgid(__gid_t rgid, __gid_t egid, __gid_t sgid);
// int sscanf(const char * restrict s, const char * restrict format, ...);
// char * strchr(char * s, int c);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (7.4.0)
// Detected functions: 4
