//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_4006d8(void);
int32_t function_400710(int32_t c);
int32_t function_400720(char * s);
int32_t function_400730(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
int32_t function_400740(char * format, ...);
int64_t * function_400750(int64_t * s, int32_t c, int32_t n);
int32_t function_400760(int64_t main, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)());
void function_400770(int32_t seed);
int32_t function_400780(char * s1, char * s2);
void function_400790(void);
int32_t function_4007a0(int32_t * timer);
int32_t function_4007b0(int64_t request, ...);
struct _IO_FILE * function_4007c0(char * filename, char * modes);
int32_t function_4007d0(char * nptr);
int32_t function_4007e0(char * format, ...);
void function_4007f0(int32_t status);
int32_t function_400800(void);
int64_t function_400840(void);
int64_t function_400870(int64_t * a1);
int64_t function_4008b0(void);
int64_t function_4008d0(void);
int64_t function_4008fd(int64_t a1, int64_t a2);
int64_t function_4009aa(void);
int64_t function_400a5b(int64_t * a1, int64_t a2);
int64_t function_400afe(int64_t a1);
int64_t function_400bd0(int64_t a1, int64_t a2, int64_t a3);
int64_t function_400c40(void);
int64_t function_400c44(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x4008d0; // 0x601e10
int64_t g2 = 0x4008b0; // 0x601e18
int64_t g3 = 0; // 0x601ff8
char (*g4)[19] = "VerySuperSeKretKey"; // 0x6020b0
char * g5 = "#<=;7<=*\a+,=>967ii`\ayy\a%"; // 0x6020c0
int64_t g6 = 0x3d282d0b212a3d0e; // 0x6020e0
int64_t g7; // 0x6020f4
int32_t g8;

// ------------------------ Functions -------------------------

// Address range: 0x4006d8 - 0x4006f2
int64_t function_4006d8(void) {
    int64_t result = 0; // 0x4006e6
    if (g3 != 0) {
        // 0x4006e8
        __gmon_start__();
        result = &g8;
    }
    // 0x4006ed
    return result;
}

// Address range: 0x400710 - 0x400716
int32_t function_400710(int32_t c) {
    // 0x400710
    return putchar(c);
}

// Address range: 0x400720 - 0x400726
int32_t function_400720(char * s) {
    // 0x400720
    return puts(s);
}

// Address range: 0x400730 - 0x400736
int32_t function_400730(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x400730
    return fread(ptr, size, n, stream);
}

// Address range: 0x400740 - 0x400746
int32_t function_400740(char * format, ...) {
    // 0x400740
    return printf(format);
}

// Address range: 0x400750 - 0x400756
int64_t * function_400750(int64_t * s, int32_t c, int32_t n) {
    // 0x400750
    return memset(s, c, n);
}

// Address range: 0x400760 - 0x400766
int32_t function_400760(int64_t main, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x400760
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x400770 - 0x400776
void function_400770(int32_t seed) {
    // 0x400770
    srand(seed);
}

// Address range: 0x400780 - 0x400786
int32_t function_400780(char * s1, char * s2) {
    // 0x400780
    return strcmp(s1, s2);
}

// Address range: 0x400790 - 0x400796
void function_400790(void) {
    // 0x400790
    __gmon_start__();
}

// Address range: 0x4007a0 - 0x4007a6
int32_t function_4007a0(int32_t * timer) {
    // 0x4007a0
    return time(timer);
}

// Address range: 0x4007b0 - 0x4007b6
int32_t function_4007b0(int64_t request, ...) {
    // 0x4007b0
    return ptrace(request);
}

// Address range: 0x4007c0 - 0x4007c6
struct _IO_FILE * function_4007c0(char * filename, char * modes) {
    // 0x4007c0
    return fopen(filename, modes);
}

// Address range: 0x4007d0 - 0x4007d6
int32_t function_4007d0(char * nptr) {
    // 0x4007d0
    return atoi(nptr);
}

// Address range: 0x4007e0 - 0x4007e6
int32_t function_4007e0(char * format, ...) {
    // 0x4007e0
    return scanf(format);
}

// Address range: 0x4007f0 - 0x4007f6
void function_4007f0(int32_t status) {
    // 0x4007f0
    exit(status);
}

// Address range: 0x400800 - 0x400806
int32_t function_400800(void) {
    // 0x400800
    return rand();
}

// Address range: 0x400810 - 0x40083a
int64_t entry_point(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x400810
    int64_t v1; // 0x400810
    __libc_start_main(0x4008fd, (int32_t)a4, (char **)&v1, (void (*)())0x400bd0, (void (*)())0x400c40, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x400840 - 0x400869
int64_t function_400840(void) {
    // 0x400840
    return 7;
}

// Address range: 0x400870 - 0x4008a9
int64_t function_400870(int64_t * a1) {
    // 0x400870
    return 0;
}

// Address range: 0x4008b0 - 0x4008cc
int64_t function_4008b0(void) {
    // 0x4008b0
    int64_t result; // 0x4008b0
    if (*(char *)0x6020f4 == 0) {
        int64_t v1 = function_400840(); // 0x4008bd
        *(char *)&g7 = 1;
        result = v1;
    }
    // 0x4008ca
    return result;
}

// Address range: 0x4008d0 - 0x4008fd
int64_t function_4008d0(void) {
    // 0x4008d0
    int64_t v1; // 0x4008d0
    return function_400870((int64_t *)v1);
}

// Address range: 0x4008fd - 0x4009aa
int64_t function_4008fd(int64_t a1, int64_t a2) {
    // 0x4008fd
    srand(time(NULL));
    int32_t v1 = rand(); // 0x40091d
    uint16_t v2 = (int16_t)(-126 * ((v1 + (int32_t)(-0x7df7df7d * (int64_t)v1 / 0x100000000)) / 64 - (v1 >> 31)) + v1) + 1; // 0x40094e
    int32_t v3; // 0x4008fd
    if ((int32_t)a1 < 2) {
        // 0x400983
        v3 = 0x1000000 * (int32_t)v2 / 0x1000000;
        goto lab_0x40098a;
    } else {
        int32_t str_as_i = atoi((char *)*(int64_t *)(a2 + 8)); // 0x400966
        if ((char)str_as_i < 0) {
            // 0x40097a
            v3 = 0x1000000 * (int32_t)v2 / 0x1000000;
            goto lab_0x40098a;
        } else {
            int32_t v4 = 0x1000000 * str_as_i / 0x1000000; // 0x40096b
            v3 = v4;
            if ((char)v4 != 127) {
                goto lab_0x40098a;
            } else {
                // 0x40097a
                v3 = 0x1000000 * (int32_t)v2 / 0x1000000;
                goto lab_0x40098a;
            }
        }
    }
  lab_0x40098a:;
    int64_t v5 = function_4009aa(); // 0x40098f
    int64_t result = v5; // 0x400996
    if ((int32_t)v5 != 0) {
        // 0x400998
        result = function_400a5b(&g6, (int64_t)v3);
    }
    // 0x4009a8
    return result;
}

// Address range: 0x4009aa - 0x400a5b
int64_t function_4009aa(void) {
    struct _IO_FILE * file = fopen("/tmp/secret", "rb"); // 0x4009bc
    if (file == NULL) {
        // 0x4009cc
        exit(-2);
        // UNREACHABLE
    }
    // 0x4009d6
    int64_t data; // bp-120, 0x4009aa
    memset(&data, 0, 100);
    fread(&data, 1, 100, file);
    if (strcmp((char *)&data, g4) != 0) {
        // 0x400a2d
        char v1; // 0x4009aa
        char v2; // 0x4009aa
        char v3; // 0x4009aa
        return v1 == -17 == v2 == -66 == v3 == -83 == (char)data == -34;
    }
    // 0x400a23
    exit(1);
    // UNREACHABLE
}

// Address range: 0x400a5b - 0x400afe
int64_t function_400a5b(int64_t * a1, int64_t a2) {
    char v1 = *(char *)a1; // 0x400aa4
    char v2 = a2; // 0x400aa7
    if (v1 != v2) {
        int32_t v3 = 0; // 0x400aaf
        int64_t v4 = (int64_t)a1; // 0x400a9b
        v3++;
        printf("%x", (int32_t)(v1 ^ v2));
        v4++;
        char v5 = *(char *)v4; // 0x400aa4
        while (v3 < 18 == (v5 != v2)) {
            // 0x400a7d
            v3++;
            printf("%x", (int32_t)(v5 ^ v2));
            v4++;
            v5 = *(char *)v4;
        }
    }
    // 0x400aba
    if (ptrace(0) != -1) {
        // 0x400ae8
        putchar(10);
        return puts("Are you sure it's the right one? ..");
    }
    // 0x400ade
    exit(1);
    // UNREACHABLE
}

// Address range: 0x400afe - 0x400bc6
int64_t function_400afe(int64_t a1) {
    char v1 = 0; // bp-20, 0x400b21
    if (ptrace(0) == -1) {
        // 0x400b4c
        exit(1);
        // UNREACHABLE
    }
    char v2 = *(char *)&g5; // 0x400b7f
    char v3 = a1; // 0x400b82
    if (v2 == v3) {
        // 0x400b95
        putchar(10);
        printf("--hit any key");
        return scanf("%c", &v1);
    }
    // 0x400b87
    v1 = 1;
    char * v4 = (char *)&g5; // 0x400b76
    printf("%x", (int32_t)(v2 ^ v3));
    v4 = (char *)((int64_t)v4 + 1);
    while (*v4 != v3) {
        unsigned char v5 = v1;
        v1 = v5 + 1;
        if (v5 >= 24) {
            // break -> 0x400b95
            break;
        }
        // 0x400b58
        printf("%x", (int32_t)(*v4 ^ v3));
        v4 = (char *)((int64_t)v4 + 1);
    }
    // 0x400b95
    putchar(10);
    printf("--hit any key");
    return scanf("%c", &v1);
}

// Address range: 0x400bd0 - 0x400c35
int64_t function_400bd0(int64_t a1, int64_t a2, int64_t a3) {
    int64_t result = function_4006d8(); // 0x400bfe
    if ((int64_t)&g2 - (int64_t)&g1 >> 3 == 0) {
        // 0x400c26
        return result;
    }
    int64_t v1 = 0; // 0x400c06
    while (v1 + 1 != (int64_t)&g2 - (int64_t)&g1 >> 3) {
        // 0x400c10
        v1++;
    }
    // 0x400c26
    return result;
}

// Address range: 0x400c40 - 0x400c42
int64_t function_400c40(void) {
    // 0x400c40
    int64_t result; // 0x400c40
    return result;
}

// Address range: 0x400c44 - 0x400c4d
int64_t function_400c44(void) {
    // 0x400c44
    int64_t result; // 0x400c44
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// void __gmon_start__(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// int atoi(const char * nptr);
// void exit(int status);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// size_t fread(void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// void * memset(void * s, int c, size_t n);
// int printf(const char * restrict format, ...);
// long int ptrace(enum __ptracerequest __request, ...);
// int putchar(int c);
// int puts(const char * s);
// int rand(void);
// int scanf(const char * restrict format, ...);
// void srand(unsigned int seed);
// int strcmp(const char * s1, const char * s2);
// time_t time(time_t * timer);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.8.5)
// Detected functions: 29
